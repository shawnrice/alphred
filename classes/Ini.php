<?php

namespace Alphred;


class Ini {

	/**
	 * Parses an INI
	 *
	 * This is a slightly better INI parser in that will read a section title of
	 * 'title:subtitle' 'subtitle' as a subsection of the section 'title'.
	 *
	 * @param  string  $file      path to the ini file to read
	 * @param  boolean $exception whether or not to throw an exception on file not found
	 * @return array|boolean      an array that represents the ini file
	 */
	public function read_ini( $file, $exception = true ) {
		if ( ! file_exists( $file ) ) {
			if ( $exception ) {
				throw new FileDoesNotExist( "File `{$file}` not found." );
			} else {
				return false;
			}
		}

		// Parse the INI files
		$ini = parse_ini_file( $file, true );
		$array = [];
		foreach( $ini as $key => $value ) :
			if ( is_array( $value ) ) {
				$array = array_merge_recursive( $array, self::parse_section( $key, $value ) );
			} else {
				array_unshift( $array, [ $key => $value ] );
			}
		endforeach;

		return $array;

	}

	/**
	 * Writes an INI file from an array
	 *
	 * @todo Do filesystem checks
	 *
	 * @param  array  $array  the array to be translated into an ini file
	 * @param  string $file  the full path to the ini file, should have '.ini'
	 */
	public function write_ini( $array, $file ) {

		$sections = self::collapse_sections( $array );
		ksort( $sections );

		$base = basename( $file );

		$contents = ";;;;;\r\n";
		$contents .= "; `{$base}` generated by Alphred v" . ALPHRED_VERSION . "\r\n";
		$contents .= "; at " . date( 'Y-M-d H:i:s', time() ) . "\r\n";
		$contents .= ";;;;;\r\n\r\n";

		foreach ( $sections as $title => $section ) :
			if ( ! is_integer( $title ) ) {
				$contents .= "\n[$title]\n";
			}
			$contents .= self::print_section( $section );

		endforeach;

		file_put_contents( $file, $contents );
	}

	/**
	 * Prints the section of an INI file
	 *
	 * @param  array $section  an array
	 * @return string          the array as an ini section
	 */
	private function print_section( $section ) {
		$contents = '';
		foreach( $section as $key => $value ) :
			if ( is_array( $value ) ) {
				foreach( $value as $v ) :
						$contents .= "{$key}[] = {$v}\r\n";
				endforeach;
			} else {
				$contents .= "{$key} = {$value}\r\n";
			}
		endforeach;
		return $contents;
	}

	private function collapse_sections( $array ) {
		return self::step_back( self::flatten_array( $array ) );
	}

	/**
	 * Flattens an associate array
	 *
	 * @param  array $array    an array to be flattened
	 * @param  string $prefix  a prefix for a key
	 * @return array           the array, but flattened
	 */
	private function flatten_array( $array, $prefix = '' ) {
			if ( ! is_array( $array ) ) {
				return $array;
			}
			if ( ! self::is_assoc( $array ) ) {
				return $array;
			}

	    $result = [];

	    foreach ( $array as $key => $value ) :

	        $new_key = $prefix . ( empty( $prefix ) ? '' : ':') . $key;

	      	if ( is_integer( $key ) ) {
	      		// Don't compound numeric keys
	      		$result[ $key ] = $value;
	      	} else if ( is_array( $value ) && self::is_assoc( $value ) ) {
	            $result = array_merge( $result, self::flatten_array( $value, $new_key ) );
	        } else {
	            $result[ $new_key ] = $value;
	        }
	    endforeach;

	    return $result;
	}

	/**
	 * Slightly unflattens an array
	 *
	 * So, flatten_array goes one step too far with the flattening, but I
	 * don't know how many levels down I need to flatten (2, 97?), so we just flatten
	 * all the way and then step back one level, which is what this function does.
	 *
	 * @param  array $array a flattened array
	 * @return array        a slightly less flat array
	 */
	private function step_back( $array ) {
		$new = [];
		foreach( $array as $key => $value ) :
		  if ( substr_count( $key, ':' ) >= 1 ) {
				$pos = strrpos( $key, ':' );
				$section = substr( $key, 0, $pos );
				$new_key = substr( $key, $pos + 1 );
				$new[ $section ][ $new_key ] = $value;
			} else {
				$new[ $key ] = $value;
			}
		endforeach;
		return $new;
	}


	/**
	 * Parses an ini section into its subsections
	 *
	 * @param  string $name   a string that should be turned into an array
	 * @param  mixed $values  the values for an array
	 * @return array          the newly-dimensional array with $values
	 */
	private function parse_section( $name, $values ) {
		if ( false !== strpos( $name, ':' ) ) {
			$pieces = explode( ':', $name );
			$pieces = array_filter( $pieces, 'trim' );
		} else {
			return [ $name => $values ];
		}
		return self::nest_array( $pieces, $values );
	}

	/**
	 * Recursively nests an array
	 *
	 * @param  array $array   the pieces to nest
	 * @param  mixed $values  the values for the bottom level of the newly dimensional array
	 * @return array          a slightly more dimensional array than we received
	 */
	private function nest_array( $array, $values ) {
	    if ( empty( $array ) ) {
	        return $values;
	    }
	    return [ array_shift( $array ) => self::nest_array( $array, $values ) ];
	}

	/**
	 * Checks if an array is associative
	 *
	 * Shamelessly stolen from http://stackoverflow.com/a/14669600/1399574
	 *
	 * @param  array  	$array an array
	 * @return boolean         whether it is associative
	 */
	private function is_assoc( $array ) {
	    // Keys of the array
	    $keys = array_keys( $array );

	    // If the array keys of the keys match the keys, then the array must
	    // not be associative (e.g. the keys array looked like {0:0, 1:1...}).
	    return array_keys( $keys ) !== $keys;
	}
}
